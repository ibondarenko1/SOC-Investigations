name: Auto create case from issue

on:
  issues:
    types: [opened, edited, labeled]

jobs:
  generate-case:
    if: >
      github.event.issue.state == 'open' &&
      contains(join(github.event.issue.labels.*.name, ','), 'new-case')
    runs-on: ubuntu-latest

    permissions:
      contents: write
      pull-requests: write
      issues: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse, create/advance branch, commit file, open PR
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';

            function grab(label) {
              const re = new RegExp(`(?<=###\\s*${label}[\\s\\S]*?)\\n\\n([\\s\\S]*?)(?=\\n###|$)`, 'i');
              const m = body.match(re);
              return m ? m[1].trim() : '';
            }

            const fromTitle = (issue.title || '')
              .toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '').slice(0, 60);

            const id = (grab('Case ID \\(slug-friendly\\)') || fromTitle || `case-${issue.number}`)
              .toLowerCase().replace(/[^a-z0-9-]/g, '-').replace(/^-+|-+$/g, '');

            const title = grab('Case Title') || issue.title || id;
            const summary = grab('Summary') || '—';

            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const base  = context.payload.repository.default_branch;
            const headBranch = `auto/case/${id}`;
            const headRefStr = `refs/heads/${headBranch}`;

            // 1) получаем SHA базовой ветки
            const { data: baseRef } = await github.rest.git.getRef({ owner, repo, ref: `heads/${base}` });

            // 2) создаём ветку, если её нет. Если есть (422) — просто читаем текущую
            let parentSha;
            try {
              await github.rest.git.createRef({ owner, repo, ref: headRefStr, sha: baseRef.object.sha });
              parentSha = baseRef.object.sha; // свежесозданная ветка указывает на base
            } catch (e) {
              if (e.status !== 422) throw e; // иная ошибка — пробрасываем
              const { data: headRef } = await github.rest.git.getRef({ owner, repo, ref: `heads/${headBranch}` });
              parentSha = headRef.object.sha; // ветка уже есть — продолжаем от её головы
            }

            // 3) содержимое файла
            const content = `# ${title} (${id})\n\n## Summary\n${summary}\n`;

            // 4) достаём дерево родительского коммита
            const { data: parentCommit } = await github.rest.git.getCommit({ owner, repo, commit_sha: parentSha });

            // 5) создаём blob и дерево с новым файлом
            const { data: blob } = await github.rest.git.createBlob({
              owner, repo,
              content: Buffer.from(content, 'utf8').toString('base64'),
              encoding: 'base64'
            });

            const { data: tree } = await github.rest.git.createTree({
              owner, repo, base_tree: parentCommit.tree.sha,
              tree: [{ path: `cases/${id}/README.md`, mode: '100644', type: 'blob', sha: blob.sha }]
            });

            // 6) коммитим
            const { data: newCommit } = await github.rest.git.createCommit({
              owner, repo,
              message: `Add case: ${id}`,
              tree: tree.sha,
              parents: [parentSha]
            });

            // 7) передвигаем указатель ветки на новый коммит
            await github.rest.git.updateRef({
              owner, repo, ref: `heads/${headBranch}`, sha: newCommit.sha, force: false
            });

            // 8) открываем PR (если уже есть — игнорируем 422)
            const prTitle = `Add case: ${title} (${id})`;
            try {
              await github.rest.pulls.create({
                owner, repo, title: prTitle, head: headBranch, base,
                body: `Auto-generated from issue #${issue.number}.`
              });
            } catch (e) {
              if (e.status !== 422) throw e; // PR уже существует — это ок
            }
